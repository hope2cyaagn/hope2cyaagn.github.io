<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.png">
  <link rel="mask-icon" href="/images/favicon.png" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="img{     width: 70%; }   1.数组1.704  二分查找  题目中给出有序数组&amp;&amp;无重复元素，这时应该想到使用二分法。 主要关键点在于while中循环的条件，我习惯[ ]左闭右闭的原则，这样的话while中的条件应为left &lt;&#x3D; right，循环体内为left &#x3D; mid + 1;和right &#x3D; mid - 1;。 12345678910111">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode做题记录">
<meta property="og:url" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/index.html">
<meta property="og:site_name" content="Diane&#39;s Blog">
<meta property="og:description" content="img{     width: 70%; }   1.数组1.704  二分查找  题目中给出有序数组&amp;&amp;无重复元素，这时应该想到使用二分法。 主要关键点在于while中循环的条件，我习惯[ ]左闭右闭的原则，这样的话while中的条件应为left &lt;&#x3D; right，循环体内为left &#x3D; mid + 1;和right &#x3D; mid - 1;。 12345678910111">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-704-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-27-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-27-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-977-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-209-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-209-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-59-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-59-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-35-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-34-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-69-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-367-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-203-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-203-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-707-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-707-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-206-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-206-2.png">
<meta property="og:image" content="http://example.com/2023/Library/Application%20Support/typora-user-images/image-20230822133505121.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-3.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-4.png">
<meta property="og:image" content="http://example.com/2023/Library/Application%20Support/typora-user-images/image-20230822182718595.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-3.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-3.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-4.png">
<meta property="og:image" content="http://example.com/2023/Library/Application%20Support/typora-user-images/image-20230822193157211.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-141-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-2.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-3.png">
<meta property="og:image" content="http://example.com/2023/Library/Application%20Support/typora-user-images/image-20230823165831112.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3-242-1.png">
<meta property="og:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3-242-2.png">
<meta property="article:published_time" content="2023-03-03T05:21:19.000Z">
<meta property="article:modified_time" content="2023-10-05T13:30:23.324Z">
<meta property="article:author" content="Diane Wang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-704-1.png">

<link rel="canonical" href="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>LeetCode做题记录 | Diane's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Diane's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/favicon.png">
      <meta itemprop="name" content="Diane Wang">
      <meta itemprop="description" content="价格回归价值">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Diane's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          LeetCode做题记录
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-03-03 13:21:19" itemprop="dateCreated datePublished" datetime="2023-03-03T13:21:19+08:00">2023-03-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <style> 
img{
    width: 70%;
}
</style>

<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1.数组"></a>1.数组</h3><h4 id="1-704-二分查找"><a href="#1-704-二分查找" class="headerlink" title="1.704  二分查找"></a>1.704  二分查找</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-704-1.png"> </p>
<p>题目中给出<strong>有序数组</strong>&amp;&amp;<strong>无重复元素</strong>，这时应该想到使用<strong>二分法</strong>。</p>
<p>主要关键点在于<code>while</code>中循环的条件，我习惯<code>[ ]</code>左闭右闭的原则，这样的话<code>while</code>中的条件应为<code>left &lt;= right</code>，循环体内为<code>left = mid + 1;</code>和<code>right = mid - 1;</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//定义target在左闭右闭的区间中[left, right]</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>; <span class="comment">//(left + right)/2可能会溢出</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-27-移除元素"><a href="#1-27-移除元素" class="headerlink" title="1.27  移除元素"></a>1.27  移除元素</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-27-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-27-2.png"></p>
<p>题目中要求<strong>不使用额外的数组空间</strong>&amp;&amp;<strong>原地修改数组</strong>，采用<strong>双指针法</strong>。</p>
<p>定义两个指针<code>fast</code>和<code>slow</code>，初始都指向起始位置<code>0</code>，用快指针进行<code>for</code>循环遍历，若<code>arr[fast] != target</code>，那么赋值给慢指针<code>arr[slow] = arr[fast];</code>，慢指针为新数组的下标位置，最后返回<code>slow</code>。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;fast &lt; nums.<span class="built_in">size</span>();fast ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[fast] != val) &#123;</span><br><span class="line">                nums[slow ++] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow; <span class="comment">//慢指针为新数组的下标位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h4 id="1-977-有序数组的平方"><a href="#1-977-有序数组的平方" class="headerlink" title="1.977  有序数组的平方"></a>1.977  有序数组的平方</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-977-1.png"></p>
<p>题目中给出数组<strong>已排序</strong>并要求返回的数组也按照<strong>非递减顺序</strong>排序，采用<strong>双指针法</strong>。</p>
<p>左右两边元素的平方应为最大值，定义<code>slow</code>为<code>0</code>，<code>fast</code>为<code>size - 1</code>，从两边向中间比较，平方较大的元素<code>push</code>进新的<code>vector</code>。</p>
<p>新建<code>vector</code>时应注意<strong>元素个数</strong>与原来数组中的元素个数相同，或者采用头插法应该也可以。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortedSquares</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(nums.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = pos;i &lt;= j;) &#123; <span class="comment">//i &lt;= j因为最后要处理两个元素</span></span><br><span class="line">            <span class="keyword">if</span>(nums[i] * nums[i] &lt; nums[j] * nums[j])</span><br><span class="line">                result[pos --] = nums[j] * nums[j --];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                result[pos --] = nums[i] * nums[i ++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️1-209-长度最小的子数组"><a href="#⭐️1-209-长度最小的子数组" class="headerlink" title="⭐️1.209  长度最小的子数组"></a>⭐️1.209  长度最小的子数组</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-209-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-209-2.png"></p>
<p>题目中要求为<strong>长度最小的子数组</strong>，使用<strong>滑动窗口</strong>的思想。</p>
<p>定义<code>i</code>、<code>j</code>，<code>j</code>为滑动窗口的尾部，<code>i</code>为头部，初始值均为<code>0</code>，对<code>j</code>进行<code>for</code>循环遍历。</p>
<p>首先寻找<code>i</code>为<code>0</code>时<code>sum &gt;= target</code>的长度<code>j</code>，固定<code>j</code>并将<code>i ++</code>，若<code>sum</code>仍<code>&gt;= target</code>，更新长度值。注意考虑不存在返回<code>0</code>的情况。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>,sum = <span class="number">0</span>; <span class="comment">//i头部 j尾部</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; nums.<span class="built_in">size</span>();j ++) &#123;</span><br><span class="line">            sum += nums[j];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target) &#123; <span class="comment">//缩小窗口</span></span><br><span class="line">                result = ((j - i + <span class="number">1</span>) &lt; result) ? j - i + <span class="number">1</span> : result; <span class="comment">//更新长度</span></span><br><span class="line">                sum -= nums[i ++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (result != <span class="number">0x3f3f3f3f</span>) ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-59-螺旋矩阵II"><a href="#1-59-螺旋矩阵II" class="headerlink" title="1.59  螺旋矩阵II"></a>1.59  螺旋矩阵II</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-59-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-59-2.png"></p>
<p>这道题🈚️算法，但需要考虑<strong>边界值</strong>，遵循<strong>循环不变量</strong>。</p>
<p>顺时针螺旋排列<code>while</code>中包含四个<code>for</code>循环（需要上下左右四条边），每个边遵守<code>[ )</code><strong>左闭右开</strong>的原则，故需要填入<code>n - offset</code>个元素，四边循环一次后<code>offset ++</code>，共需循环<code>n / 2 </code>次。</p>
<p>需要定义的<strong>变量</strong>：</p>
<ul>
<li><p>偏离值<code>offset</code></p>
</li>
<li><p>循环层数<code>loop</code></p>
</li>
<li><p>起始位置<code>startx</code>和<code>starty</code></p>
</li>
<li><p>填入数字<code>count</code></p>
</li>
<li><p><code>n</code>为奇数最后需填入中心值<code>pow(n,2)</code></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">generateMatrix</span>(<span class="type">int</span> n) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">result</span>(n,<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n)); <span class="comment">//定义二维数组</span></span><br><span class="line">        <span class="type">int</span> count = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> offset = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> startx = <span class="number">0</span>,starty = <span class="number">0</span>; <span class="comment">//每循环一个圈的起始位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> loop = <span class="number">0</span>;loop &lt; n / <span class="number">2</span>; loop ++) &#123; <span class="comment">//需要循环几个圈</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - offset;i ++) &#123; <span class="comment">//圈中的边需要填入多少个数字</span></span><br><span class="line">                result[startx][starty ++] = count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - offset;i ++) &#123;</span><br><span class="line">                result[startx ++][starty] = count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - offset;i ++) &#123;</span><br><span class="line">                result[startx][starty --] = count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; n - offset;i ++) &#123;</span><br><span class="line">                result[startx --][starty] = count ++;</span><br><span class="line">            &#125;</span><br><span class="line">            startx ++;</span><br><span class="line">            starty ++;</span><br><span class="line">            offset += <span class="number">2</span>; <span class="comment">//每条边需填充的数比前一圈少2个</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">1</span>) <span class="comment">//n为奇数需填入中心值</span></span><br><span class="line">            result[n / <span class="number">2</span>][n / <span class="number">2</span>] = count;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-35-搜索插入位置"><a href="#1-35-搜索插入位置" class="headerlink" title="1.35  搜索插入位置"></a>1.35  搜索插入位置</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-35-1.png"></p>
<p>题中已给出<strong>排序数组</strong>和<strong>目标值</strong>，采用<strong>二分查找法</strong>，最后<code>return right+1;</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> pos = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right =  mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️1-34-在排序数组中查找元素的第一个和最后一个位置"><a href="#⭐️1-34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="⭐️1.34  在排序数组中查找元素的第一个和最后一个位置"></a>⭐️1.34  在排序数组中查找元素的第一个和最后一个位置</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-34-1.png"></p>
<p>题中已给出<strong>排序数组</strong>和<strong>目标值</strong>，先新建一个<code>[-1,-1]</code>的<code>vector</code>，使用<strong>二分查找法</strong>找到第一个<code>target</code>，由于是已排序，故从查找到的位置开始，分别<strong>向左向右</strong>遍历，不断更新，直至值不为<code>target</code>。若查找不到<code>target</code>，直接返回<code>vector</code>的初始值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pos</span><span class="params">(<span class="number">2</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                pos[<span class="number">0</span>] = pos[<span class="number">1</span>] = mid;</span><br><span class="line">                <span class="keyword">while</span>(pos[<span class="number">0</span>] - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; nums[pos[<span class="number">0</span>] - <span class="number">1</span>] == target) <span class="comment">//判断条件</span></span><br><span class="line">                    pos[<span class="number">0</span>] -= <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(pos[<span class="number">1</span>] + <span class="number">1</span> &lt; nums.<span class="built_in">size</span>() &amp;&amp; nums[pos[<span class="number">1</span>] + <span class="number">1</span>] == target)</span><br><span class="line">                    pos[<span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> pos;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️1-69-x的平方根"><a href="#⭐️1-69-x的平方根" class="headerlink" title="⭐️1.69  x的平方根"></a>⭐️1.69  x的平方根</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-69-1.png"></p>
<p>采用<strong>二分查找法</strong>，健壮性有所不足：</p>
<ul>
<li>需考虑<code>0</code>、<code>1</code>的情况；</li>
<li>需考虑整数溢出情况，判断条件不能使用<code>x &lt;= mid * mid</code>，而是<code>mid &lt;= x / mid</code></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">mySqrt</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span> || x == <span class="number">1</span>) </span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = x;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; (x / mid)) <span class="comment">//防止溢出</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; (x / mid))</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="1-367-有效的完全平方数"><a href="#1-367-有效的完全平方数" class="headerlink" title="1.367  有效的完全平方数"></a>1.367  有效的完全平方数</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/1-367-1.png"></p>
<p><strong>二分查找</strong>，<code>num % mid == 0</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPerfectSquare</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> right = num / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">            <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid &lt; num / mid)</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(mid &gt; num / mid)</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> num % mid == <span class="number">0</span>; <span class="comment">//判断是否为完全平方数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2.链表"></a>2.链表</h3><h4 id="2-203-移除链表元素"><a href="#2-203-移除链表元素" class="headerlink" title="2.203  移除链表元素"></a>2.203  移除链表元素</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-203-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-203-2.png"></p>
<p>对于移除的操作不陌生，但是总考虑不到特殊的测试用例，如<code>head == nullptr</code>、删除后下一个元素的<code>val</code>仍等于<code>target</code>。</p>
<p>首先若<code>head != nullptr &amp;&amp; head-&gt;val == target</code>将<code>head</code>指向下一个结点，此时再判断<code>head</code>，若为空返回<code>head</code>，而不是在一开始判断，判断后再双指针遍历删除。</p>
<p>虚拟头结点更易于理解：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeElements</span><span class="params">(ListNode* head, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        ListNode* headPtr = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>); <span class="comment">//虚拟头结点</span></span><br><span class="line">        headPtr-&gt;next = head;</span><br><span class="line">        ListNode* cur = headPtr;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;next-&gt;val != val)</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                ListNode* temp = cur-&gt;next;</span><br><span class="line">                cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">                <span class="keyword">delete</span> temp;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headPtr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️2-707-设计链表"><a href="#⭐️2-707-设计链表" class="headerlink" title="⭐️2.707  设计链表"></a>⭐️2.707  设计链表</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-707-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-707-2.png"></p>
<p>先定义<strong>链表结点结构体</strong>和初始化链表(<strong>构造函数</strong>)，注意<code>cur</code>应定义为<code>headPtr</code>还是<code>headPtr-&gt;next</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyLinkedList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">LinkedNode</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        LinkedNode* next;</span><br><span class="line">        <span class="built_in">LinkedNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">        <span class="built_in">LinkedNode</span>(<span class="type">int</span> val) : <span class="built_in">val</span>(val),<span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyLinkedList</span>() &#123;</span><br><span class="line">        headPtr = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(<span class="number">0</span>);</span><br><span class="line">        size = <span class="number">0</span>; <span class="comment">//结点个数 下标需-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        LinkedNode* p = headPtr-&gt;next;    </span><br><span class="line">        <span class="keyword">while</span>(index --)</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> p-&gt;val;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtHead</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* newHead = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        newHead-&gt;next = headPtr-&gt;next;</span><br><span class="line">        headPtr-&gt;next = newHead;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtTail</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        LinkedNode* tail = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">        LinkedNode* cur = headPtr;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = tail;</span><br><span class="line">        size ++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addAtIndex</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == size)</span><br><span class="line">            <span class="built_in">addAtTail</span>(val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            LinkedNode* cur = headPtr; <span class="comment">//插在index之前 所以cur不是headPtr-&gt;next</span></span><br><span class="line">            <span class="keyword">while</span>(index --)</span><br><span class="line">                cur = cur-&gt;next;</span><br><span class="line">            LinkedNode* newNode = <span class="keyword">new</span> <span class="built_in">LinkedNode</span>(val);</span><br><span class="line">            newNode-&gt;next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = newNode;</span><br><span class="line">            size ++;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteAtIndex</span><span class="params">(<span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index &gt; size - <span class="number">1</span> || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span>; </span><br><span class="line">        LinkedNode* cur = headPtr; </span><br><span class="line">        <span class="keyword">while</span>(index --)</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        LinkedNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = temp-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;    </span><br><span class="line">        size --;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">      <span class="type">int</span> size;</span><br><span class="line">      LinkedNode* headPtr;      </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyLinkedList object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyLinkedList* obj = new MyLinkedList();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(index);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtHead(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtTail(val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;addAtIndex(index,val);</span></span><br><span class="line"><span class="comment"> * obj-&gt;deleteAtIndex(index);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="⭐️2-206-反转链表"><a href="#⭐️2-206-反转链表" class="headerlink" title="⭐️2.206  反转链表"></a>⭐️2.206  反转链表</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-206-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-206-2.png"></p>
<h5 id="双指针："><a href="#双指针：" class="headerlink" title="双指针："></a>双指针：</h5><p>采用<strong>三指针</strong>，<code>prev</code>&#x2F;<code>cur</code>&#x2F;<code>temp</code>，还是在健壮性有所不足，要考虑到特殊的测试用例：如<strong>链表为空</strong>或链表<strong>只有头结点</strong>的情况。</p>
<p>注意<code>while</code>循环条件以及最后返回的是<code>pre</code>指针</p>
<img src="../../../Library/Application Support/typora-user-images/image-20230822133505121.png" alt="image-20230822133505121" style="zoom: 50%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* cur = head;</span><br><span class="line">        ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur) &#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h5 id="递归："><a href="#递归：" class="headerlink" title="递归："></a>递归：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(head,<span class="literal">nullptr</span>); <span class="comment">//初始化cur = head; pre = null;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* cur,ListNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> pre;</span><br><span class="line">        ListNode* temp = cur-&gt;next;</span><br><span class="line">        cur-&gt;next = pre;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">reverse</span>(temp,cur); <span class="comment">//cur = temp; pre = cur;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️2-24-两两交换链表中的节点"><a href="#⭐️2-24-两两交换链表中的节点" class="headerlink" title="⭐️2.24  两两交换链表中的节点"></a>⭐️2.24  两两交换链表中的节点</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-2.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-3.png"></p>
<p>设置一个空结点<code>newHead</code>，返回值为<code>nerHead-&gt;next</code>，交换的执行顺序很重要，顺序如下图：</p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-24-4.png"></p>
<img src="../../../Library/Application Support/typora-user-images/image-20230822182718595.png" alt="image-20230822182718595" style="zoom:33%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">swapPairs</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode* headPtr = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        headPtr-&gt;next = head;</span><br><span class="line">        ListNode* cur = headPtr;</span><br><span class="line">        ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* temp1 = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur-&gt;next != <span class="literal">nullptr</span> &amp;&amp; cur-&gt;next-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            temp = cur-&gt;next;</span><br><span class="line">            temp1 = cur-&gt;next-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next = cur-&gt;next-&gt;next;</span><br><span class="line">            cur-&gt;next-&gt;next = temp;</span><br><span class="line">            cur-&gt;next-&gt;next-&gt;next = temp1;</span><br><span class="line">            cur = cur-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headPtr-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-19-删除链表的倒数第N个结点"><a href="#2-19-删除链表的倒数第N个结点" class="headerlink" title="2.19  删除链表的倒数第N个结点"></a>2.19  删除链表的倒数第N个结点</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-2.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-19-3.png"></p>
<p>采用<strong>双指针法</strong>，令<code>fast</code>指针先走<code>n</code>&#x2F;<code>n + 1</code>步(根据结束位置判断决定)，而后<code>fast ++ </code>直至<code>nullptr</code>，删除结点。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode() : val(0), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x, ListNode *next) : val(x), next(next) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* headPtr = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        headPtr-&gt;next = head;</span><br><span class="line">        ListNode* fast = headPtr;</span><br><span class="line">        ListNode* slow = headPtr;</span><br><span class="line">        <span class="keyword">while</span>(n -- &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>)</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* temp = slow-&gt;next;</span><br><span class="line">        slow-&gt;next = slow-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> temp;</span><br><span class="line">        <span class="keyword">return</span> headPtr-&gt;next;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️2-160-相交链表"><a href="#⭐️2-160-相交链表" class="headerlink" title="⭐️2.160  相交链表"></a>⭐️2.160  相交链表</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-2.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-3.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-160-4.png"></p>
<p>先<strong>遍历</strong><code>链表A</code>与<code>链表B</code>的长度，计算<strong>差值</strong>，将较长链表先前进差值，然后开始遍历判断，若两指针指向相同，则返回。</p>
<p>不能用<code>val</code>判断，需要指向地址相同。</p>
<p>仍然是代码<strong>健壮性</strong>的问题，注意只有一个元素的情况，新增一个头结点可以解决这个问题。在链表问题中<strong>新增头结点</strong>可以使很多边界值判断变简单。</p>
<img src="../../../Library/Application Support/typora-user-images/image-20230822193157211.png" alt="image-20230822193157211" style="zoom:33%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="literal">nullptr</span> || headB == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* ptrA = headA;</span><br><span class="line">        ListNode* ptrB = headB;</span><br><span class="line">        <span class="keyword">while</span>(ptrA != ptrB) &#123;</span><br><span class="line">            ptrA = (ptrA == <span class="literal">NULL</span>) ? headB : ptrA-&gt;next;</span><br><span class="line">            ptrB = (ptrB == <span class="literal">NULL</span>) ? headA : ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> lenA = <span class="number">0</span>,lenB = <span class="number">0</span>;</span><br><span class="line">        ListNode *ptrA = headA;</span><br><span class="line">        ListNode *ptrB = headB;</span><br><span class="line">        <span class="keyword">while</span>(ptrA != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lenA ++;</span><br><span class="line">            ptrA = ptrA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptrB != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            lenB ++;</span><br><span class="line">            ptrB = ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> diff = (lenA &gt;= lenB) ? lenA - lenB : lenB - lenA;</span><br><span class="line">        ptrA = headA;</span><br><span class="line">        ptrB = headB;</span><br><span class="line">        <span class="keyword">if</span>(lenA &lt;= lenB) &#123;</span><br><span class="line">            <span class="keyword">while</span>(diff --)</span><br><span class="line">                ptrB = ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(diff --)</span><br><span class="line">                ptrA = ptrA-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(ptrA != ptrB) &#123;</span><br><span class="line">            ptrA = ptrA-&gt;next;</span><br><span class="line">            ptrB = ptrB-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ptrA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-141-环形链表"><a href="#2-141-环形链表" class="headerlink" title="2.141  环形链表"></a>2.141  环形链表</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-141-1.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-142-环形链表II"><a href="#2-142-环形链表II" class="headerlink" title="2.142  环形链表II"></a>2.142  环形链表II</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-2.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/2-142-3.png"></p>
<img src="../../../Library/Application Support/typora-user-images/image-20230823165831112.png" alt="image-20230823165831112" style="zoom:33%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                <span class="keyword">while</span>(slow != fast) &#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> fast;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-哈希表"><a href="#3-哈希表" class="headerlink" title="3.哈希表"></a>3.哈希表</h3><p>哈希法解决问题常用的数据结构：</p>
<ul>
<li>数组</li>
<li><code>set</code>（集合）</li>
<li><code>map</code>（映射）</li>
</ul>
<p>在C++中，<code>set</code>和<code>map</code>分别提供以下三种数据结构，其底层实现以及优劣如下所示</p>
<table>
<thead>
<tr>
<th align="center">集合</th>
<th align="center">底层实现</th>
<th align="center">是否有序</th>
<th align="center">数值是否可以重复</th>
<th align="center">能否更改数值</th>
<th align="center">查询效率</th>
<th align="center">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>std::set</code></td>
<td align="center">红黑树</td>
<td align="center">有序</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><code>O(log n)</code></td>
<td align="center"><code>O(log n)</code></td>
</tr>
<tr>
<td align="center"><code>std::multiset</code></td>
<td align="center">红黑树</td>
<td align="center">有序</td>
<td align="center">是</td>
<td align="center">否</td>
<td align="center"><code>O(log n)</code></td>
<td align="center"><code>O(log n)</code></td>
</tr>
<tr>
<td align="center"><code>std::unordered_set</code></td>
<td align="center">哈希表</td>
<td align="center">无序</td>
<td align="center">否</td>
<td align="center">否</td>
<td align="center"><code>O(1)</code></td>
<td align="center"><code>O(1)</code></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">映射</th>
<th align="center">底层实现</th>
<th align="center">是否有序</th>
<th align="center">数值是否可以重复</th>
<th align="center">能否更改数值</th>
<th align="center">查询效率</th>
<th align="center">增删效率</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>std::map</code></td>
<td align="center">红黑树</td>
<td align="center"><code>key</code>有序</td>
<td align="center"><code>key</code>不可重复</td>
<td align="center"><code>key</code>不可修改</td>
<td align="center"><code>O(log n)</code></td>
<td align="center"><code>O(log n)</code></td>
</tr>
<tr>
<td align="center"><code>std::multimap</code></td>
<td align="center">红黑树</td>
<td align="center"><code>key</code>有序</td>
<td align="center"><code>key</code>可重复</td>
<td align="center"><code>key</code>不可修改</td>
<td align="center"><code>O(log n)</code></td>
<td align="center"><code>O(log n)</code></td>
</tr>
<tr>
<td align="center"><code>std::unordered_map</code></td>
<td align="center">哈希表</td>
<td align="center"><code>key</code>无序</td>
<td align="center"><code>key</code>不可重复</td>
<td align="center"><code>key</code>不可修改</td>
<td align="center"><code>O(1)</code></td>
<td align="center"><code>O(1)</code></td>
</tr>
</tbody></table>
<blockquote>
<p>当我们要使用集合来解决哈希问题的时候，优先使用<code>unordered_set</code>，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用<code>set</code>，如果要求不仅有序还要有重复数据的话，那么就用<code>multiset</code></p>
</blockquote>
<h4 id="3-242-有效的字母异位词"><a href="#3-242-有效的字母异位词" class="headerlink" title="3.242 有效的字母异位词"></a>3.242 有效的字母异位词</h4><p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3-242-1.png"></p>
<p><img src="/2023/03/03/LeetCode%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/3-242-2.png"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isAnagram</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> hash[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(s[i])</span><br><span class="line">            hash[s[i ++] - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">        <span class="keyword">while</span>(t[j])</span><br><span class="line">            hash[t[j ++] - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hash[i] != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-349-两个数组的交集"><a href="#3-349-两个数组的交集" class="headerlink" title="3.349  两个数组的交集"></a>3.349  两个数组的交集</h4><p>![image-20230829094954758](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829094954758.png)</p>
<p>![image-20230829095012484](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829095012484.png)</p>
<p>输出的结果是去重的， 同时可以不考虑输出结果的顺序，那么可以使用<code>unordered_set</code>，将<code>nums1</code>储存到<code>set</code>中，遍历<code>nums2</code>同时查询该元素是否存在于<code>set</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">intersection</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt;<span class="built_in">nums</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num : nums2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums.<span class="built_in">find</span>(num) != nums.<span class="built_in">end</span>())</span><br><span class="line">                result.<span class="built_in">insert</span>(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-202-快乐数"><a href="#3-202-快乐数" class="headerlink" title="3.202  快乐数"></a>3.202  快乐数</h4><p>![image-20230829095535579](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829095535579.png)</p>
<p>![image-20230829095557170](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829095557170.png)</p>
<p>题中给出最后结果可能为1，或者无限循环，那么就意味着如果不是快乐数，在求和过程中，<code>sum</code>一定会重复出现，所以可以使用<code>unordered_set</code>判断<code>sum</code>是否重复出现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isHappy</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> temp,sum;</span><br><span class="line">        unordered_set&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(sum != <span class="number">1</span>) &#123;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(n &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">                temp = n % <span class="number">10</span>;</span><br><span class="line">                n = n / <span class="number">10</span>;</span><br><span class="line">                sum += temp * temp;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += n * n;</span><br><span class="line">            <span class="keyword">if</span>(v.<span class="built_in">find</span>(sum) == v.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                v.<span class="built_in">insert</span>(sum);</span><br><span class="line">                n = sum;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(sum == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-两数之和"><a href="#3-1-两数之和" class="headerlink" title="3.1  两数之和"></a>3.1  两数之和</h4><p>![image-20230829100303202](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829100303202.png)</p>
<p>![image-20230829100318142](..&#x2F;..&#x2F;..&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20230829100318142.png)</p>
<p>题目要求返回下标，那么使用<code>map</code>来储存元素值与元素下标，遍历<code>nums</code>数组同时判断<code>map</code>中是否存在使得和为<code>target</code>的另一个数，若存在返回，否则将这个数插入到<code>map</code>中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = map.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(iter != map.<span class="built_in">end</span>())</span><br><span class="line">                <span class="keyword">return</span> &#123;iter-&gt;second,i&#125;;</span><br><span class="line">            map.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(nums[i],i));      </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-454-四数相加-II"><a href="#3-454-四数相加-II" class="headerlink" title="3.454  四数相加 II"></a>3.454  四数相加 II</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fourSumCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2, vector&lt;<span class="type">int</span>&gt;&amp; nums3, vector&lt;<span class="type">int</span>&gt;&amp; nums4)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; record;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num1 : nums1) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num2 : nums2) &#123;</span><br><span class="line">                record[num1 + num2] ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num3 : nums3) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> num4 : nums4) &#123;</span><br><span class="line">                <span class="keyword">if</span>(record.<span class="built_in">find</span>(<span class="number">0</span> - (num3 + num4)) != record.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    count += record[<span class="number">0</span> - (num3 + num4)];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-383-赎金信"><a href="#3-383-赎金信" class="headerlink" title="3.383  赎金信"></a>3.383  赎金信</h4><p>选错数据结构了，原来使用的map，但是使用数组更好</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">canConstruct</span><span class="params">(string ransomNote, string magazine)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> record[<span class="number">26</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">char</span>* ch = &amp;magazine[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(*ch != <span class="number">0</span>) &#123;</span><br><span class="line">            record[*ch - <span class="string">&#x27;a&#x27;</span>] ++;</span><br><span class="line">            ch ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>* ptr = &amp;ransomNote[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span>(*ptr != <span class="number">0</span>) &#123;</span><br><span class="line">            record[*ptr - <span class="string">&#x27;a&#x27;</span>] --;</span><br><span class="line">            <span class="keyword">if</span>(record[*ptr - <span class="string">&#x27;a&#x27;</span>] &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">            ptr ++;   </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-15-三数之和"><a href="#3-15-三数之和" class="headerlink" title="3.15  三数之和"></a>3.15  三数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i,left,right;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            left = i + <span class="number">1</span>,right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) </span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;    </span><br><span class="line">            <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &gt; <span class="number">0</span>)</span><br><span class="line">                    right --;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] + nums[left] + nums[right] &lt; <span class="number">0</span>)</span><br><span class="line">                    left ++;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result.<span class="built_in">push_back</span>(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(&#123;nums[i],nums[left],nums[right]&#125;));</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                        left ++;</span><br><span class="line">                    <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                        right --;</span><br><span class="line">                    left ++;</span><br><span class="line">                    right --;        </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="3-18-四数之和"><a href="#3-18-四数之和" class="headerlink" title="3.18  四数之和"></a>3.18  四数之和</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">fourSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i,j,left,right;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; target &amp;&amp; nums[i] &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;    </span><br><span class="line">            <span class="keyword">for</span>(j = i + <span class="number">1</span>;j &lt; nums.<span class="built_in">size</span>();j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] + nums[j] &gt; target &amp;&amp; nums[i] + nums[j] &gt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>(j &gt; i + <span class="number">1</span> &amp;&amp; nums[j] == nums[j - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                left = j + <span class="number">1</span>;</span><br><span class="line">                right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;    </span><br><span class="line">                <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">if</span>((<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &gt; target)</span><br><span class="line">                        right --;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>((<span class="type">long</span>)nums[i] + nums[j] + nums[left] + nums[right] &lt; target)    </span><br><span class="line">                        left ++;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        result.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[left],nums[right]&#125;);</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>])</span><br><span class="line">                            left ++;</span><br><span class="line">                        <span class="keyword">while</span>(left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>])</span><br><span class="line">                            right --;</span><br><span class="line">                        left ++;</span><br><span class="line">                        right --;      </span><br><span class="line">                    &#125;    </span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="4-字符串"><a href="#4-字符串" class="headerlink" title="4.字符串"></a>4.字符串</h3><h4 id="4-344-反转字符串"><a href="#4-344-反转字符串" class="headerlink" title="4.344  反转字符串"></a>4.344  反转字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseString</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>,right = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="type">char</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">            temp = s[left];</span><br><span class="line">            s[left ++] = s[right];</span><br><span class="line">            s[right --] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️4-541-反转字符串II"><a href="#⭐️4-541-反转字符串II" class="headerlink" title="⭐️4.541  反转字符串II"></a>⭐️4.541  反转字符串II</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseStr</span><span class="params">(string s, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i += (<span class="number">2</span> * k)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i + k &lt; s.<span class="built_in">size</span>())</span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">begin</span>() + i + k);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + i,s.<span class="built_in">end</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️4-剑指Offer05-替换空格（这道题按双指针法再做一遍，注意库函数复杂度✅"><a href="#⭐️4-剑指Offer05-替换空格（这道题按双指针法再做一遍，注意库函数复杂度✅" class="headerlink" title="⭐️4.剑指Offer05  替换空格（这道题按双指针法再做一遍，注意库函数复杂度✅"></a>⭐️4.剑指Offer05  替换空格（这道题按双指针法再做一遍，注意库函数复杂度✅</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> oldSize = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                count ++;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(oldSize + <span class="number">2</span> * count);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s.<span class="built_in">size</span>() - <span class="number">1</span>,j = oldSize - <span class="number">1</span>;j &lt; i;j --) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[j] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                s[i --] = s[j];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                s[i --] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                s[i --] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">                s[i --] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            &#125;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️4-151-反转字符串中的单词"><a href="#⭐️4-151-反转字符串中的单词" class="headerlink" title="⭐️4.151  反转字符串中的单词"></a>⭐️4.151  反转字符串中的单词</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeExtraSpaces</span><span class="params">(string &amp;s)</span> </span>&#123; <span class="comment">//去掉字符串中多余空格</span></span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] != <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(slow != <span class="number">0</span>)</span><br><span class="line">                    s[slow ++] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">                <span class="keyword">while</span>(s[i] != <span class="string">&#x27; &#x27;</span> &amp;&amp; i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">                    s[slow ++] = s[i ++];    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        s.<span class="built_in">resize</span>(slow);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reverseStr</span><span class="params">(string &amp;s,<span class="type">int</span> start,<span class="type">int</span> end)</span> </span>&#123; <span class="comment">//反转单词</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = start,j = end;i &lt; j;i ++,j --)</span><br><span class="line">            <span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">removeExtraSpaces</span>(s);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,start = <span class="number">0</span>;i &lt;= s.<span class="built_in">size</span>();++ i) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27; &#x27;</span> || i == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="built_in">reverseStr</span>(s,start,i - <span class="number">1</span>);</span><br><span class="line">                start = i + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-剑指offer58-左旋转字符串II"><a href="#4-剑指offer58-左旋转字符串II" class="headerlink" title="4.剑指offer58  左旋转字符串II"></a>4.剑指offer58  左旋转字符串II</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>() + n,s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-28-找出字符串中第一个匹配项的下标"><a href="#4-28-找出字符串中第一个匹配项的下标" class="headerlink" title="4.28  找出字符串中第一个匹配项的下标"></a>4.28  找出字符串中第一个匹配项的下标</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> string needle,vector&lt;<span class="type">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">        next.<span class="built_in">resize</span>(needle.<span class="built_in">size</span>());</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>; <span class="comment">//j为后缀末尾，也是i之前（包括i）子串最长相等前后缀的长度</span></span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; needle.<span class="built_in">size</span>();i ++) &#123; <span class="comment">//i为前缀末尾</span></span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) <span class="comment">//前后缀不相同</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(needle[i] == needle[j]) <span class="comment">//前后缀相同</span></span><br><span class="line">                next[i] = ++ j; <span class="comment">//更新next</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; next;</span><br><span class="line">        <span class="built_in">getNext</span>(needle,next);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>,j = <span class="number">0</span>;i &lt; haystack.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) <span class="comment">//元素不相同</span></span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(haystack[i] == needle[j]) <span class="comment">//元素相同</span></span><br><span class="line">                j ++;</span><br><span class="line">            <span class="keyword">if</span>(j == needle.<span class="built_in">size</span>()) <span class="comment">//匹配字符串成功</span></span><br><span class="line">                <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="4-459-重复的子字符串"><a href="#4-459-重复的子字符串" class="headerlink" title="4.459  重复的子字符串"></a>4.459  重复的子字符串</h4><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangtianq/p/5839909.html">https://www.cnblogs.com/zhangtianq/p/5839909.html</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 1</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">GetNext</span><span class="params">(<span class="type">char</span>* p,<span class="type">int</span> next[])</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="type">int</span> pLen = <span class="built_in">strlen</span>(p);  </span><br><span class="line">    next[<span class="number">0</span>] = <span class="number">-1</span>;  </span><br><span class="line">    <span class="type">int</span> k = <span class="number">-1</span>;  </span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">while</span> (j &lt; pLen - <span class="number">1</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="comment">//p[k]表示前缀，p[j]表示后缀  </span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">-1</span> || p[j] == p[k])   </span><br><span class="line">        &#123;  </span><br><span class="line">            ++k;  </span><br><span class="line">            ++j;  </span><br><span class="line">            next[j] = k;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">        &#123;  </span><br><span class="line">            k = next[k];  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method 2</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>,j = <span class="number">0</span>;j &lt; s.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">    <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j]) &#123;</span><br><span class="line">    		j = next[j - <span class="number">1</span>];</span><br><span class="line">  	&#125;</span><br><span class="line">  	<span class="keyword">if</span>(s[i] == s[j]) &#123;</span><br><span class="line">      	j ++;</span><br><span class="line">    &#125;</span><br><span class="line">  	next[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getNext</span><span class="params">(<span class="type">const</span> string s,vector&lt;<span class="type">int</span>&gt; &amp;next)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>,max = <span class="number">-1</span>;</span><br><span class="line">        next[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt; s.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; s[i] != s[j])</span><br><span class="line">                j = next[j - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[j])</span><br><span class="line">                next[i] = ++ j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(size)</span></span>;</span><br><span class="line">        <span class="built_in">getNext</span>(s,next);</span><br><span class="line">        <span class="type">int</span> commonMax = next[size - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//commonMax == 0可能会出现ababac的情况（正整数整除它本身余数为0</span></span><br><span class="line">        <span class="comment">//commonMax是指这个字符串的最长公共前后缀，而不是这个字符串中所有子串的最长公共前后缀</span></span><br><span class="line">        <span class="keyword">if</span>(commonMax != <span class="number">0</span> &amp;&amp; size % (size - commonMax) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="5-栈与队列"><a href="#5-栈与队列" class="headerlink" title="5.栈与队列"></a>5.栈与队列</h3><h4 id="5-232-用栈实现队列"><a href="#5-232-用栈实现队列" class="headerlink" title="5.232  用栈实现队列"></a>5.232  用栈实现队列</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack_In;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stack_Out;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack_In.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack_Out.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack_In.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                stack_Out.<span class="built_in">push</span>(stack_In.<span class="built_in">top</span>());</span><br><span class="line">                stack_In.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> result = stack_Out.<span class="built_in">top</span>();</span><br><span class="line">        stack_Out.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="keyword">this</span>-&gt;<span class="built_in">pop</span>();</span><br><span class="line">        stack_Out.<span class="built_in">push</span>(ret);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack_In.<span class="built_in">empty</span>() &amp;&amp; stack_Out.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue* obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;peek();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="5-225-用队列实现队栈"><a href="#5-225-用队列实现队栈" class="headerlink" title="5.225  用队列实现队栈"></a>5.225  用队列实现队栈</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que1;</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; que2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        que1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size = que1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size - <span class="number">1</span>;i ++) &#123;</span><br><span class="line">            que2.<span class="built_in">push</span>(que1.<span class="built_in">front</span>());</span><br><span class="line">            que1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        result = que1.<span class="built_in">front</span>();</span><br><span class="line">        que1 = que2;</span><br><span class="line">        <span class="keyword">while</span>(!que2.<span class="built_in">empty</span>())</span><br><span class="line">            que2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que1.<span class="built_in">empty</span>() &amp;&amp; que2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyStack* obj = new MyStack();</span></span><br><span class="line"><span class="comment"> * obj-&gt;push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj-&gt;pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj-&gt;top();</span></span><br><span class="line"><span class="comment"> * bool param_4 = obj-&gt;empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h4 id="5-20-有效的括号"><a href="#5-20-有效的括号" class="headerlink" title="5.20  有效的括号"></a>5.20  有效的括号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stack;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; s.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;]&#x27;</span>);    </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">&#x27;&#123;&#x27;</span>)</span><br><span class="line">                stack.<span class="built_in">push</span>(<span class="string">&#x27;&#125;&#x27;</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!stack.<span class="built_in">empty</span>() &amp;&amp; s[i] == stack.<span class="built_in">top</span>())</span><br><span class="line">                stack.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-1047-删除字符串中的所有相邻重复项"><a href="#5-1047-删除字符串中的所有相邻重复项" class="headerlink" title="5.1047  删除字符串中的所有相邻重复项"></a>5.1047  删除字符串中的所有相邻重复项</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicates</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> ch : s) &#123;</span><br><span class="line">            <span class="keyword">if</span>(!st.<span class="built_in">empty</span>() &amp;&amp; ch == st.<span class="built_in">top</span>())</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(ch);    </span><br><span class="line">        &#125;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result += st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-150-逆波兰表达式求值"><a href="#5-150-逆波兰表达式求值" class="headerlink" title="5.150  逆波兰表达式求值"></a>5.150  逆波兰表达式求值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">evalRPN</span><span class="params">(vector&lt;string&gt;&amp; tokens)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; st;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; tokens.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span> || tokens[i] == <span class="string">&quot;-&quot;</span> || tokens[i] == <span class="string">&quot;*&quot;</span> || tokens[i] == <span class="string">&quot;/&quot;</span>) &#123;</span><br><span class="line">                <span class="type">int</span> count1 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> count2 = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;+&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(count2 + count1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;-&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(count2 - count1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;*&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(count2 * count1);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(tokens[i] == <span class="string">&quot;/&quot;</span>)</span><br><span class="line">                    st.<span class="built_in">push</span>(count2 / count1);  </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="built_in">stoi</span>(tokens[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-239-滑动窗口最大值"><a href="#5-239-滑动窗口最大值" class="headerlink" title="5.239  滑动窗口最大值"></a>5.239  滑动窗口最大值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    deque&lt;<span class="type">int</span>&gt; que;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!que.<span class="built_in">empty</span>() &amp;&amp; value == que.<span class="built_in">front</span>())</span><br><span class="line">            que.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>() &amp;&amp; que.<span class="built_in">back</span>() &lt; value)</span><br><span class="line">            que.<span class="built_in">pop_back</span>();</span><br><span class="line">        que.<span class="built_in">push_back</span>(value);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> que.<span class="built_in">front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        myQueue que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; k;i ++) &#123;</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        result.<span class="built_in">push_back</span>(que.<span class="built_in">getMax</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k;i &lt; nums.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            que.<span class="built_in">pop</span>(nums[i - k]);</span><br><span class="line">            que.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            result.<span class="built_in">push_back</span>(que.<span class="built_in">getMax</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-347-前-K-个高频元素"><a href="#5-347-前-K-个高频元素" class="headerlink" title="5.347  前 K 个高频元素"></a>5.347  前 K 个高频元素</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">MyComparison</span> &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; pair1,<span class="type">const</span> pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&amp; pair2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pair1.second &gt; pair2.second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">topKFrequent</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; record;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;,MyComparison&gt; heap;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; nums.<span class="built_in">size</span>();i ++) &#123;</span><br><span class="line">            <span class="comment">// auto it = record.find(nums[i]);</span></span><br><span class="line">            <span class="comment">// if(it != record.end())</span></span><br><span class="line">            <span class="comment">//     it-&gt;second ++;</span></span><br><span class="line">            <span class="comment">// else</span></span><br><span class="line">            <span class="comment">//     record.insert(pair&lt;int,int&gt;(nums[i],1));    </span></span><br><span class="line">            record[nums[i]]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; it : record) &#123;</span><br><span class="line">            heap.<span class="built_in">push</span>(it);</span><br><span class="line">            <span class="keyword">if</span>(heap.<span class="built_in">size</span>() &gt; k)</span><br><span class="line">                heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!heap.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            result.<span class="built_in">push_back</span>(heap.<span class="built_in">top</span>().first);</span><br><span class="line">            heap.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="6-二叉树"><a href="#6-二叉树" class="headerlink" title="6.二叉树"></a>6.二叉树</h3><h4 id="5-144-二叉树的前序遍历"><a href="#5-144-二叉树的前序遍历" class="headerlink" title="5.144  二叉树的前序遍历"></a>5.144  二叉树的前序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    </span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-145-二叉树的后序遍历"><a href="#5-145-二叉树的后序遍历" class="headerlink" title="5.145  二叉树的后序遍历"></a>5.145  二叉树的后序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        st.<span class="built_in">push</span>(root);    </span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            result.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;left);    </span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-94-二叉树的中序遍历"><a href="#5-94-二叉树的中序遍历" class="headerlink" title="5.94  二叉树的中序遍历"></a>5.94  二叉树的中序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur,vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left,vec);</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right,vec);    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">traversal</span>(root,result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        TreeNode* cur = root; </span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="literal">nullptr</span> || !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                st.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cur = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(cur-&gt;val);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-102-二叉树的层序遍历"><a href="#5-102-二叉树的层序遍历" class="headerlink" title="5.102  二叉树的层序遍历"></a>5.102  二叉树的层序遍历</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">            <span class="keyword">while</span>(size --) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(ret);</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-107-二叉树的层序遍历II"><a href="#5-107-二叉树的层序遍历II" class="headerlink" title="5.107  二叉树的层序遍历II"></a>5.107  二叉树的层序遍历II</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">levelOrderBottom</span>(TreeNode* root) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; result;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; ret;</span><br><span class="line">            <span class="keyword">while</span>(size --) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                ret.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);    </span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(ret);</span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="built_in">reverse</span>(result.<span class="built_in">begin</span>(),result.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> result;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="5-199-二叉树的右视图"><a href="#5-199-二叉树的右视图" class="headerlink" title="5.199 二叉树的右视图"></a>5.199 二叉树的右视图</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">rightSideView</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; size;i ++) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(i == size - <span class="number">1</span>)</span><br><span class="line">                    result.<span class="built_in">push_back</span>(temp-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);  </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-637-二叉树的层平均值"><a href="#5-637-二叉树的层平均值" class="headerlink" title="5.637  二叉树的层平均值"></a>5.637  二叉树的层平均值</h4><h4 id="5-429-N叉树的层序遍历"><a href="#5-429-N叉树的层序遍历" class="headerlink" title="5.429  N叉树的层序遍历"></a>5.429  N叉树的层序遍历</h4><h4 id="5-515-在每个树行中找最大值"><a href="#5-515-在每个树行中找最大值" class="headerlink" title="5.515  在每个树行中找最大值"></a>5.515  在每个树行中找最大值</h4><h4 id="5-116-填充每个节点的下一个右侧节点指针"><a href="#5-116-填充每个节点的下一个右侧节点指针" class="headerlink" title="5.116  填充每个节点的下一个右侧节点指针"></a>5.116  填充每个节点的下一个右侧节点指针</h4><p>有递归版本<code>connect</code></p>
<h4 id="5-104-二叉树的最大深度"><a href="#5-104-二叉树的最大深度" class="headerlink" title="5.104  二叉树的最大深度"></a>5.104  二叉树的最大深度</h4><h4 id="5-111-二叉树的最小深度"><a href="#5-111-二叉树的最小深度" class="headerlink" title="5.111  二叉树的最小深度"></a>5.111  二叉树的最小深度</h4><h4 id="5-543-二叉树的直径"><a href="#5-543-二叉树的直径" class="headerlink" title="5.543  二叉树的直径"></a>5.543  二叉树的直径</h4><h4 id="5-226-翻转二叉树"><a href="#5-226-翻转二叉树" class="headerlink" title="5.226  翻转二叉树"></a>5.226  翻转二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);    </span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">invertTree</span>(root-&gt;right);</span><br><span class="line">        <span class="built_in">swap</span>(root-&gt;left,root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//前序遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* temp = st.<span class="built_in">top</span>();</span><br><span class="line">            st.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="built_in">swap</span>(temp-&gt;left,temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;right);</span><br><span class="line">            <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                st.<span class="built_in">push</span>(temp-&gt;left);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; <span class="comment">//层序遍历</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="type">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(size --) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="built_in">swap</span>(temp-&gt;left,temp-&gt;right);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-101-对称二叉树"><a href="#5-101-对称二叉树" class="headerlink" title="5.101  对称二叉树"></a>5.101  对称二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//递归法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">compare</span><span class="params">(TreeNode* left,TreeNode* right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left == <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(left != <span class="literal">nullptr</span> &amp;&amp; right != <span class="literal">nullptr</span> &amp;&amp; left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> outside = <span class="built_in">compare</span>(left-&gt;left,right-&gt;right);</span><br><span class="line">        <span class="type">bool</span> inside = <span class="built_in">compare</span>(left-&gt;right,right-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> outside &amp;&amp; inside;            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">compare</span>(root-&gt;left,root-&gt;right);    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代法</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        que.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* leftNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode* rightNode = que.<span class="built_in">front</span>();</span><br><span class="line">            que.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!leftNode &amp;&amp; !rightNode)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((!leftNode || !rightNode || (leftNode-&gt;val != rightNode-&gt;val)))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;left);</span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(leftNode-&gt;right);</span><br><span class="line">            que.<span class="built_in">push</span>(rightNode-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-104-二叉树的最大深度-1"><a href="#5-104-二叉树的最大深度-1" class="headerlink" title="5.104  二叉树的最大深度"></a>5.104  二叉树的最大深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//递归法（后序遍历）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="type">int</span> height = <span class="number">1</span> + <span class="built_in">max</span>(leftHeight,rightHeight);</span><br><span class="line">        <span class="keyword">return</span> height;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">max</span>(<span class="built_in">maxDepth</span>(root-&gt;left),<span class="built_in">maxDepth</span>(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//迭代法（层序遍历）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size,depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            size = que.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">while</span>(size --) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);    </span><br><span class="line">            &#125;</span><br><span class="line">            depth ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="5-111-二叉树的最小深度-1"><a href="#5-111-二叉树的最小深度-1" class="headerlink" title="5.111  二叉树的最小深度"></a>5.111  二叉树的最小深度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//递归法（前序遍历）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftHeight = <span class="built_in">getHeight</span>(root-&gt;left);</span><br><span class="line">        <span class="type">int</span> rightHeight = <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + rightHeight;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; root-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + leftHeight;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + <span class="built_in">min</span>(leftHeight,rightHeight);            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//迭代法（层序遍历）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> size,depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> depth;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        que.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            size = que.<span class="built_in">size</span>();</span><br><span class="line">            depth ++;</span><br><span class="line">            <span class="keyword">while</span>(size --) &#123;</span><br><span class="line">                TreeNode* temp = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;left)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;left);  </span><br><span class="line">                <span class="keyword">if</span>(temp-&gt;right)</span><br><span class="line">                    que.<span class="built_in">push</span>(temp-&gt;right);    </span><br><span class="line">                <span class="keyword">if</span>(!temp-&gt;left &amp;&amp; !temp-&gt;right) </span><br><span class="line">                    <span class="keyword">return</span> depth; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> depth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>














    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/03/02/Cpp%E9%9A%8F%E6%9C%BA%E6%95%B0/" rel="prev" title="C++随机数">
      <i class="fa fa-chevron-left"></i> C++随机数
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/25/%E5%B8%B8%E7%94%A8Git%E5%91%BD%E4%BB%A4/" rel="next" title="常用Git命令">
      常用Git命令 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">1.数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-704-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE"><span class="nav-number">1.1.</span> <span class="nav-text">1.704  二分查找</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-number">1.2.</span> <span class="nav-text">1.27  移除元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-977-%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9"><span class="nav-number">1.3.</span> <span class="nav-text">1.977  有序数组的平方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F1-209-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84"><span class="nav-number">1.4.</span> <span class="nav-text">⭐️1.209  长度最小的子数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-59-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5II"><span class="nav-number">1.5.</span> <span class="nav-text">1.59  螺旋矩阵II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.6.</span> <span class="nav-text">1.35  搜索插入位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F1-34-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%92%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE"><span class="nav-number">1.7.</span> <span class="nav-text">⭐️1.34  在排序数组中查找元素的第一个和最后一个位置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F1-69-x%E7%9A%84%E5%B9%B3%E6%96%B9%E6%A0%B9"><span class="nav-number">1.8.</span> <span class="nav-text">⭐️1.69  x的平方根</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-367-%E6%9C%89%E6%95%88%E7%9A%84%E5%AE%8C%E5%85%A8%E5%B9%B3%E6%96%B9%E6%95%B0"><span class="nav-number">1.9.</span> <span class="nav-text">1.367  有效的完全平方数</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">2.链表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-203-%E7%A7%BB%E9%99%A4%E9%93%BE%E8%A1%A8%E5%85%83%E7%B4%A0"><span class="nav-number">2.1.</span> <span class="nav-text">2.203  移除链表元素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F2-707-%E8%AE%BE%E8%AE%A1%E9%93%BE%E8%A1%A8"><span class="nav-number">2.2.</span> <span class="nav-text">⭐️2.707  设计链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F2-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">2.3.</span> <span class="nav-text">⭐️2.206  反转链表</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88%EF%BC%9A"><span class="nav-number">2.3.1.</span> <span class="nav-text">双指针：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%EF%BC%9A"><span class="nav-number">2.3.2.</span> <span class="nav-text">递归：</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F2-24-%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">2.4.</span> <span class="nav-text">⭐️2.24  两两交换链表中的节点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E7%BB%93%E7%82%B9"><span class="nav-number">2.5.</span> <span class="nav-text">2.19  删除链表的倒数第N个结点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F2-160-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8"><span class="nav-number">2.6.</span> <span class="nav-text">⭐️2.160  相交链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-141-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8"><span class="nav-number">2.7.</span> <span class="nav-text">2.141  环形链表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-142-%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II"><span class="nav-number">2.8.</span> <span class="nav-text">2.142  环形链表II</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">3.哈希表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-242-%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D"><span class="nav-number">3.1.</span> <span class="nav-text">3.242 有效的字母异位词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-349-%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%BB%84%E7%9A%84%E4%BA%A4%E9%9B%86"><span class="nav-number">3.2.</span> <span class="nav-text">3.349  两个数组的交集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-202-%E5%BF%AB%E4%B9%90%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">3.202  快乐数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.4.</span> <span class="nav-text">3.1  两数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-454-%E5%9B%9B%E6%95%B0%E7%9B%B8%E5%8A%A0-II"><span class="nav-number">3.5.</span> <span class="nav-text">3.454  四数相加 II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-383-%E8%B5%8E%E9%87%91%E4%BF%A1"><span class="nav-number">3.6.</span> <span class="nav-text">3.383  赎金信</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.7.</span> <span class="nav-text">3.15  三数之和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-18-%E5%9B%9B%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="nav-number">3.8.</span> <span class="nav-text">3.18  四数之和</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.</span> <span class="nav-text">4.字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-344-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.1.</span> <span class="nav-text">4.344  反转字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F4-541-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="nav-number">4.2.</span> <span class="nav-text">⭐️4.541  反转字符串II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F4-%E5%89%91%E6%8C%87Offer05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC%EF%BC%88%E8%BF%99%E9%81%93%E9%A2%98%E6%8C%89%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95%E5%86%8D%E5%81%9A%E4%B8%80%E9%81%8D%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%BA%93%E5%87%BD%E6%95%B0%E5%A4%8D%E6%9D%82%E5%BA%A6%E2%9C%85"><span class="nav-number">4.3.</span> <span class="nav-text">⭐️4.剑指Offer05  替换空格（这道题按双指针法再做一遍，注意库函数复杂度✅</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E2%AD%90%EF%B8%8F4-151-%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8D%95%E8%AF%8D"><span class="nav-number">4.4.</span> <span class="nav-text">⭐️4.151  反转字符串中的单词</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-%E5%89%91%E6%8C%87offer58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2II"><span class="nav-number">4.5.</span> <span class="nav-text">4.剑指offer58  左旋转字符串II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-28-%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87"><span class="nav-number">4.6.</span> <span class="nav-text">4.28  找出字符串中第一个匹配项的下标</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-459-%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">4.7.</span> <span class="nav-text">4.459  重复的子字符串</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">5.</span> <span class="nav-text">5.栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-232-%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">5.1.</span> <span class="nav-text">5.232  用栈实现队列</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-225-%E7%94%A8%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0%E9%98%9F%E6%A0%88"><span class="nav-number">5.2.</span> <span class="nav-text">5.225  用队列实现队栈</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-20-%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7"><span class="nav-number">5.3.</span> <span class="nav-text">5.20  有效的括号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1047-%E5%88%A0%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E7%9B%B8%E9%82%BB%E9%87%8D%E5%A4%8D%E9%A1%B9"><span class="nav-number">5.4.</span> <span class="nav-text">5.1047  删除字符串中的所有相邻重复项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-150-%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC"><span class="nav-number">5.5.</span> <span class="nav-text">5.150  逆波兰表达式求值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-239-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">5.6.</span> <span class="nav-text">5.239  滑动窗口最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-347-%E5%89%8D-K-%E4%B8%AA%E9%AB%98%E9%A2%91%E5%85%83%E7%B4%A0"><span class="nav-number">5.7.</span> <span class="nav-text">5.347  前 K 个高频元素</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.</span> <span class="nav-text">6.二叉树</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-144-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.1.</span> <span class="nav-text">5.144  二叉树的前序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-145-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.2.</span> <span class="nav-text">5.145  二叉树的后序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-94-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.3.</span> <span class="nav-text">5.94  二叉树的中序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-102-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.4.</span> <span class="nav-text">5.102  二叉树的层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-107-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86II"><span class="nav-number">6.5.</span> <span class="nav-text">5.107  二叉树的层序遍历II</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-199-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%8F%B3%E8%A7%86%E5%9B%BE"><span class="nav-number">6.6.</span> <span class="nav-text">5.199 二叉树的右视图</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-637-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC"><span class="nav-number">6.7.</span> <span class="nav-text">5.637  二叉树的层平均值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-429-N%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-number">6.8.</span> <span class="nav-text">5.429  N叉树的层序遍历</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-515-%E5%9C%A8%E6%AF%8F%E4%B8%AA%E6%A0%91%E8%A1%8C%E4%B8%AD%E6%89%BE%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">6.9.</span> <span class="nav-text">5.515  在每个树行中找最大值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-116-%E5%A1%AB%E5%85%85%E6%AF%8F%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%8F%B3%E4%BE%A7%E8%8A%82%E7%82%B9%E6%8C%87%E9%92%88"><span class="nav-number">6.10.</span> <span class="nav-text">5.116  填充每个节点的下一个右侧节点指针</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6"><span class="nav-number">6.11.</span> <span class="nav-text">5.104  二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6"><span class="nav-number">6.12.</span> <span class="nav-text">5.111  二叉树的最小深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-543-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E7%9B%B4%E5%BE%84"><span class="nav-number">6.13.</span> <span class="nav-text">5.543  二叉树的直径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-226-%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.14.</span> <span class="nav-text">5.226  翻转二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-101-%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">6.15.</span> <span class="nav-text">5.101  对称二叉树</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-104-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6-1"><span class="nav-number">6.16.</span> <span class="nav-text">5.104  二叉树的最大深度</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-111-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6-1"><span class="nav-number">6.17.</span> <span class="nav-text">5.111  二叉树的最小深度</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Diane Wang"
      src="/images/favicon.png">
  <p class="site-author-name" itemprop="name">Diane Wang</p>
  <div class="site-description" itemprop="description">价格回归价值</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">11</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2022 – 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Diane Wang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
